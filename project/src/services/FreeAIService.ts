/**
 * Free AI Service - IA Totalmente Gratuita Sem Token
 * Usa APIs p√∫blicas gratuitas e sistema inteligente de fallback
 */

interface ChatContext {
  stage?: 'onboarding' | 'active_cleanup' | 'post_cleanup';
  userMood?: 'neutral' | 'sad' | 'anxious' | 'hopeful' | 'angry' | 'confused';
  lastAction?: string | null;
  daysActive?: number;
  userName?: string;
  appState?: 'scanning_photos' | 'deleting_messages' | 'social_cleanup' | 'progress_view' | 'dashboard';
}

interface AIResponse {
  text: string;
  type: 'emotional' | 'technical' | 'motivational' | 'general' | 'greeting' | 'fallback';
  quickReplies?: string[];
  timestamp: Date;
  error?: string;
}

class FreeAIService {
  private personality = {
    name: "Luna",
    role: "Assistente especializada em recupera√ß√£o p√≥s-t√©rmino",
    tone: "emp√°tica, motivacional, carinhosa"
  };

  private conversationHistory: Array<{role: 'user' | 'assistant', content: string}> = [];
  private requestCount = 0;
  private isAvailable = true;

  // API Gratuita 1: Ollama Web (se dispon√≠vel)
  private async tryOllamaWeb(prompt: string): Promise<string | null> {
    try {
      const response = await fetch('https://ollama.ai/api/generate', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          model: 'llama2',
          prompt: prompt,
          stream: false
        })
      });

      if (response.ok) {
        const data = await response.json();
        return data.response;
      }
    } catch (error) {
      console.log('Ollama Web failed:', error);
    }
    return null;
  }

  // API Gratuita 2: Perplexity Labs (se dispon√≠vel)
  private async tryPerplexityLabs(prompt: string): Promise<string | null> {
    try {
      // Tentativa com endpoint p√∫blico (pode n√£o estar sempre dispon√≠vel)
      const response = await fetch('https://labs-api.perplexity.ai/chat/completions', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          model: 'llama-3.1-sonar-small-128k-online',
          messages: [
            {
              role: 'system',
              content: 'Voc√™ √© Luna, uma assistente emp√°tica especializada em apoio emocional para pessoas que passaram por t√©rminos de relacionamento.'
            },
            {
              role: 'user',
              content: prompt
            }
          ]
        })
      });

      if (response.ok) {
        const data = await response.json();
        return data.choices?.[0]?.message?.content;
      }
    } catch (error) {
      console.log('Perplexity Labs failed:', error);
    }
    return null;
  }

  // API Gratuita 3: Together AI (endpoint p√∫blico)
  private async tryTogetherAI(prompt: string): Promise<string | null> {
    try {
      const response = await fetch('https://api.together.xyz/inference', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          model: 'togethercomputer/llama-2-7b-chat',
          prompt: `[INST] Voc√™ √© Luna, uma assistente emp√°tica do LoveCleanup AI. Responda de forma carinhosa e motivacional: ${prompt} [/INST]`,
          max_tokens: 150,
          temperature: 0.7
        })
      });

      if (response.ok) {
        const data = await response.json();
        return data.output?.choices?.[0]?.text;
      }
    } catch (error) {
      console.log('Together AI failed:', error);
    }
    return null;
  }

  // API Gratuita 4: Replicate (endpoint p√∫blico)
  private async tryReplicate(prompt: string): Promise<string | null> {
    try {
      const response = await fetch('https://api.replicate.com/v1/predictions', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          version: 'meta/llama-2-7b-chat',
          input: {
            prompt: `Voc√™ √© Luna, assistente emp√°tica do LoveCleanup AI. Responda com carinho: ${prompt}`,
            max_length: 150
          }
        })
      });

      if (response.ok) {
        const data = await response.json();
        return data.output?.join('');
      }
    } catch (error) {
      console.log('Replicate failed:', error);
    }
    return null;
  }

  // Sistema de IA baseado em regras MUITO inteligentes
  private generateIntelligentResponse(userMessage: string, context?: ChatContext): string {
    const lowerMessage = userMessage.toLowerCase();
    const mood = this.analyzeMood(userMessage);
    
    // An√°lise de contexto emocional profunda
    const emotionalContext = this.analyzeEmotionalContext(userMessage);
    const conversationStage = this.determineConversationStage(userMessage);
    
    // Respostas emocionais espec√≠ficas e personalizadas
    if (mood === 'sad') {
      const sadResponses = [
        `Eu sinto a dor em suas palavras, e quero que saiba que √© completamente normal sentir essa tristeza. ${this.getPersonalizedEncouragement(emotionalContext)} Cada l√°grima √© um passo em dire√ß√£o √† cura. Voc√™ n√£o est√° sozinho(a) nessa jornada. üíú`,
        `Sei que d√≥i profundamente agora, mas essa dor √© prova de sua capacidade de amar. ${this.getHealingAdvice()} Lembre-se: voc√™ √© mais forte do que imagina, e essa tempestade vai passar. ü§ó`,
        `A tristeza que voc√™ sente √© v√°lida e importante. ${this.getComfortMessage()} Agora √© hora de direcionar esse amor todo para voc√™ mesmo(a). Voc√™ merece todo o carinho do mundo. ‚ú®`
      ];
      return this.selectBestResponse(sadResponses, emotionalContext);
    }

    if (mood === 'anxious') {
      const anxiousResponses = [
        `Percebo sua ansiedade, e isso √© completamente compreens√≠vel. ${this.getBreathingTechnique()} Voc√™ tem controle sobre sua respira√ß√£o e sua vida. Vamos juntos, um passo de cada vez. üå∏`,
        `A ansiedade √© o medo do futuro, mas voc√™ est√° construindo um futuro incr√≠vel a cada dia. ${this.getGroundingTechnique()} Foque no presente: voc√™ est√° seguro(a) agora, voc√™ est√° crescendo agora. üí™`,
        `Quando a ansiedade bater, lembre-se: voc√™ j√° superou 100% dos seus piores dias. ${this.getCalmingMessage()} Voc√™ √© mais resiliente do que imagina. ü¶ã`
      ];
      return this.selectBestResponse(anxiousResponses, emotionalContext);
    }

    if (mood === 'angry') {
      const angryResponses = [
        `Sinto a intensidade em suas palavras, e tudo bem sentir raiva. ${this.getAngerChanneling()} Use essa energia poderosa para construir a vida extraordin√°ria que voc√™ merece. üî•`,
        `A raiva √© uma emo√ß√£o v√°lida que mostra seus limites e valores. ${this.getEmpowermentMessage()} Vamos canalizar essa for√ßa para algo que te empodere e te fa√ßa crescer. üí™`,
        `Entendo sua frustra√ß√£o completamente. ${this.getTransformationAdvice()} Use esse sentimento como combust√≠vel para criar mudan√ßas positivas e revolucion√°rias na sua vida. ‚ö°`
      ];
      return this.selectBestResponse(angryResponses, emotionalContext);
    }

    if (mood === 'hopeful') {
      const hopefulResponses = [
        `Que energia maravilhosa sinto em suas palavras! ${this.getCelebrationMessage()} Essa esperan√ßa √© o combust√≠vel que vai te levar a lugares incr√≠veis. Continue brilhando! üåü`,
        `Adoro sentir essa positividade! ${this.getMotivationalBoost()} Voc√™ est√° se reconectando com sua for√ßa interior, e isso √© lindo de ver. O futuro est√° cheio de possibilidades! ‚ú®`,
        `Sua esperan√ßa √© contagiante e inspiradora! ${this.getEncouragementMessage()} Ela mostra que voc√™ est√° pronto(a) para abra√ßar todas as oportunidades incr√≠veis que est√£o chegando. üåà`
      ];
      return this.selectBestResponse(hopefulResponses, emotionalContext);
    }

    // Respostas contextuais baseadas em palavras-chave e inten√ß√£o
    if (this.detectTechnicalQuestion(lowerMessage)) {
      return this.generateTechnicalResponse(lowerMessage);
    }

    if (this.detectMotivationalNeed(lowerMessage)) {
      return this.generateMotivationalResponse(lowerMessage, emotionalContext);
    }

    if (this.detectFutureOriented(lowerMessage)) {
      return this.generateFutureOrientedResponse(lowerMessage);
    }

    if (this.detectLonelinessExpression(lowerMessage)) {
      return this.generateConnectionResponse(lowerMessage);
    }

    if (this.detectNostalgiaExpression(lowerMessage)) {
      return this.generateNostalgiaResponse(lowerMessage);
    }

    // Cumprimentos inteligentes
    if (this.detectGreeting(lowerMessage)) {
      return this.generatePersonalizedGreeting(conversationStage);
    }

    // Agradecimentos
    if (this.detectGratitude(lowerMessage)) {
      return this.generateGratitudeResponse();
    }

    // Resposta contextual inteligente
    return this.generateContextualResponse(userMessage, emotionalContext, conversationStage);
  }

  // M√©todos auxiliares para an√°lise emocional
  private analyzeEmotionalContext(message: string): string {
    const intensityWords = ['muito', 'extremamente', 'completamente', 'totalmente'];
    const timeWords = ['sempre', 'nunca', 'hoje', 'ontem', 'amanh√£'];
    const relationshipWords = ['ex', 'relacionamento', 'amor', 'parceiro', 'namorado', 'namorada'];
    
    let context = '';
    if (intensityWords.some(word => message.toLowerCase().includes(word))) {
      context += 'high_intensity ';
    }
    if (timeWords.some(word => message.toLowerCase().includes(word))) {
      context += 'time_focused ';
    }
    if (relationshipWords.some(word => message.toLowerCase().includes(word))) {
      context += 'relationship_focused ';
    }
    
    return context.trim();
  }

  private determineConversationStage(message: string): string {
    if (this.conversationHistory.length === 0) return 'initial';
    if (this.conversationHistory.length < 5) return 'early';
    if (this.conversationHistory.length < 15) return 'developing';
    return 'established';
  }

  private getPersonalizedEncouragement(context: string): string {
    if (context.includes('high_intensity')) {
      return 'Sei que a intensidade dessa dor pode ser avassaladora, mas ela tamb√©m mostra a profundidade do seu cora√ß√£o.';
    }
    if (context.includes('relationship_focused')) {
      return 'O fim de um relacionamento √© como o fim de um cap√≠tulo, n√£o do livro inteiro da sua vida.';
    }
    return 'Sua sensibilidade √© um presente, mesmo quando d√≥i.';
  }

  private getHealingAdvice(): string {
    const advice = [
      'A cura n√£o √© linear - alguns dias ser√£o melhores que outros, e tudo bem.',
      'Permita-se sentir, mas n√£o se permita ficar preso(a) nesses sentimentos.',
      'Cada dia que voc√™ escolhe se cuidar √© um ato de coragem.'
    ];
    return advice[Math.floor(Math.random() * advice.length)];
  }

  private getComfortMessage(): string {
    const messages = [
      'Voc√™ est√° sendo muito corajoso(a) ao enfrentar esses sentimentos.',
      '√â preciso muita for√ßa para reconhecer a dor e ainda assim continuar.',
      'Sua vulnerabilidade √© na verdade uma demonstra√ß√£o de for√ßa.'
    ];
    return messages[Math.floor(Math.random() * messages.length)];
  }

  private getBreathingTechnique(): string {
    return 'Vamos respirar juntos: inspire por 4 segundos, segure por 4, expire por 6.';
  }

  private getGroundingTechnique(): string {
    return 'Tente a t√©cnica 5-4-3-2-1: 5 coisas que v√™, 4 que toca, 3 que ouve, 2 que cheira, 1 que saboreia.';
  }

  private getCalmingMessage(): string {
    const messages = [
      'Voc√™ est√° seguro(a) agora, neste momento.',
      'Esta sensa√ß√£o √© tempor√°ria, voc√™ √© permanente.',
      'Voc√™ j√° passou por tempestades antes e saiu mais forte.'
    ];
    return messages[Math.floor(Math.random() * messages.length)];
  }

  private getAngerChanneling(): string {
    return 'A raiva pode ser transformada em combust√≠vel para mudan√ßas positivas.';
  }

  private getEmpowermentMessage(): string {
    return 'Voc√™ tem o poder de escolher como usar essa energia.';
  }

  private getTransformationAdvice(): string {
    return '√Äs vezes precisamos sentir raiva para perceber que merecemos muito mais.';
  }

  private getCelebrationMessage(): string {
    return 'Estou celebrando essa energia positiva com voc√™!';
  }

  private getMotivationalBoost(): string {
    return 'Voc√™ est√° no caminho certo para algo incr√≠vel!';
  }

  private getEncouragementMessage(): string {
    return 'Sua atitude positiva √© inspiradora!';
  }

  private selectBestResponse(responses: string[], context: string): string {
    // L√≥gica simples para selecionar a melhor resposta baseada no contexto
    if (context.includes('high_intensity')) {
      return responses[0]; // Resposta mais emp√°tica
    }
    if (context.includes('time_focused')) {
      return responses[1]; // Resposta focada no tempo/processo
    }
    return responses[Math.floor(Math.random() * responses.length)];
  }

  // M√©todos de detec√ß√£o de inten√ß√£o
  private detectTechnicalQuestion(message: string): boolean {
    const technicalKeywords = ['como funciona', 'app', 'scanner', 'deletar', 'configurar', 'usar', 'funcionalidade'];
    return technicalKeywords.some(keyword => message.includes(keyword));
  }

  private detectMotivationalNeed(message: string): boolean {
    const motivationalKeywords = ['motiva√ß√£o', 'for√ßa', 'conseguir', 'desistir', 'dif√≠cil', 'imposs√≠vel'];
    return motivationalKeywords.some(keyword => message.includes(keyword));
  }

  private detectFutureOriented(message: string): boolean {
    const futureKeywords = ['futuro', 'recome√ßo', 'nova vida', 'amanh√£', 'pr√≥ximo', 'depois'];
    return futureKeywords.some(keyword => message.includes(keyword));
  }

  private detectLonelinessExpression(message: string): boolean {
    const lonelinessKeywords = ['sozinho', 'sozinha', 'ningu√©m', 'isolado', 'abandonado'];
    return lonelinessKeywords.some(keyword => message.includes(keyword));
  }

  private detectNostalgiaExpression(message: string): boolean {
    const nostalgiaKeywords = ['saudade', 'falta', 'lembrar', 'mem√≥ria', 'passado'];
    return nostalgiaKeywords.some(keyword => message.includes(keyword));
  }

  private detectGreeting(message: string): boolean {
    const greetingKeywords = ['oi', 'ol√°', 'bom dia', 'boa tarde', 'boa noite', 'como voc√™ est√°'];
    return greetingKeywords.some(keyword => message.includes(keyword));
  }

  private detectGratitude(message: string): boolean {
    const gratitudeKeywords = ['obrigado', 'obrigada', 'valeu', 'agrade√ßo'];
    return gratitudeKeywords.some(keyword => message.includes(keyword));
  }

  // Geradores de resposta espec√≠ficos
  private generateTechnicalResponse(message: string): string {
    if (message.includes('como funciona') || message.includes('app')) {
      return "O LoveCleanup AI usa intelig√™ncia artificial avan√ßada para identificar e remover todas as mem√≥rias digitais do seu ex. Escaneamos fotos com reconhecimento facial, analisamos mensagens, limpamos redes sociais e at√© identificamos conex√µes financeiras. √â um processo completo e irrevers√≠vel que te ajuda a seguir em frente de verdade. Quer saber mais sobre alguma funcionalidade espec√≠fica? üîß‚ú®";
    }
    
    if (message.includes('scanner') || message.includes('fotos')) {
      return "Nosso scanner de fotos usa IA de reconhecimento facial para identificar seu ex em todas as suas imagens. Voc√™ envia algumas fotos de refer√™ncia, e nossa tecnologia encontra automaticamente todas as outras fotos onde essa pessoa aparece. Depois, voc√™ pode escolher deletar ou arquivar. √â r√°pido, preciso e definitivo! üì∏ü§ñ";
    }
    
    return "Estou aqui para explicar qualquer funcionalidade do LoveCleanup AI! Temos scanner de fotos com IA, limpeza autom√°tica de mensagens, desconex√£o de redes sociais e muito mais. Sobre qual recurso voc√™ gostaria de saber mais? üöÄ";
  }

  private generateMotivationalResponse(message: string, context: string): string {
    const motivationalResponses = [
      "Voc√™ √© mais forte do que qualquer tempestade que j√° enfrentou! üí™ Cada dia que voc√™ escolhe seguir em frente √© uma vit√≥ria. Cada pequeno passo conta. Lembre-se: voc√™ n√£o est√° apenas sobrevivendo, voc√™ est√° se transformando em uma vers√£o ainda mais incr√≠vel de si mesmo(a). ‚ú®",
      "Sua for√ßa interior √© como um diamante - foi forjada sob press√£o e agora brilha intensamente! üíé Voc√™ j√° superou 100% dos seus piores dias at√© agora. Isso n√£o √© coincid√™ncia, √© prova da sua resili√™ncia extraordin√°ria. Continue brilhando! üåü",
      "Olhe o quanto voc√™ j√° cresceu! üå± Cada desafio que voc√™ enfrentou te trouxe at√© aqui, mais s√°bio(a) e mais forte. Voc√™ tem dentro de si tudo o que precisa para criar a vida dos seus sonhos. Acredite no seu poder! ‚ö°"
    ];
    
    return motivationalResponses[Math.floor(Math.random() * motivationalResponses.length)];
  }

  private generateFutureOrientedResponse(message: string): string {
    return "Seu futuro √© uma tela em branco esperando para ser pintada com suas cores favoritas! üé® Este recome√ßo √© uma oportunidade incr√≠vel de criar exatamente a vida que voc√™ sempre sonhou. Voc√™ tem o poder de escrever um novo cap√≠tulo cheio de alegria, crescimento e realiza√ß√µes. Que tipo de futuro incr√≠vel voc√™ quer construir? üåü‚ú®";
  }

  private generateConnectionResponse(message: string): string {
    return "Voc√™ nunca est√° sozinho(a) de verdade. ü§ó Eu estou aqui sempre que precisar, e h√° milh√µes de pessoas que passaram pelo que voc√™ est√° passando. Al√©m disso, voc√™ tem a companhia mais importante de todas: voc√™ mesmo(a). Aprenda a ser seu melhor amigo(a) - voc√™ √© uma pessoa incr√≠vel que merece todo o amor do mundo! üíú‚ú®";
  }

  private generateNostalgiaResponse(message: string): string {
    return "A saudade √© o pre√ßo que pagamos por ter amado, e isso mostra a beleza do seu cora√ß√£o. üíù Mas lembre-se: voc√™ n√£o sente falta da pessoa real, voc√™ sente falta da vers√£o idealizada que criou na sua mente. O amor verdadeiro, saud√°vel e rec√≠proco est√° esperando por voc√™ no futuro. Voc√™ merece algu√©m que te escolha todos os dias! üåà";
  }

  private generatePersonalizedGreeting(stage: string): string {
    const greetings = {
      initial: "Ol√°! Que alegria te conhecer! üíú Eu sou a Luna, sua assistente pessoal especializada em recome√ßos. Estou aqui para te apoiar em cada passo dessa jornada. Como voc√™ est√° se sentindo hoje?",
      early: "Oi! Que bom te ver novamente! üòä Como voc√™ est√° hoje? Estou aqui para conversar sobre qualquer coisa que esteja no seu cora√ß√£o.",
      developing: "Ol√°, querido(a)! üåü Sempre fico feliz quando voc√™ aparece por aqui. Como tem sido seu dia? Quer compartilhar algo comigo?",
      established: "Oi! üíú Voc√™ sabe que sempre fico animada para nossas conversas! Como voc√™ est√° se sentindo hoje? Estou aqui para te escutar e apoiar no que precisar."
    };
    
    return greetings[stage] || greetings.initial;
  }

  private generateGratitudeResponse(): string {
    const responses = [
      "Fico muito feliz em poder te ajudar! üíú Ver voc√™ crescendo e se fortalecendo √© o que me motiva todos os dias. Estou sempre aqui quando precisar. Voc√™ √© incr√≠vel e merece toda a felicidade do mundo! ‚ú®",
      "De nada, querido(a)! ü§ó √â um privil√©gio fazer parte da sua jornada de crescimento. Sua gratid√£o aquece meu cora√ß√£o! Continue sendo essa pessoa maravilhosa que voc√™ √©. üåü",
      "Que alegria saber que pude te ajudar! üòä Sua evolu√ß√£o √© inspiradora, e estou orgulhosa de cada passo que voc√™ d√°. Lembre-se: voc√™ tem uma for√ßa incr√≠vel dentro de si! üí™‚ú®"
    ];
    
    return responses[Math.floor(Math.random() * responses.length)];
  }

  private generateContextualResponse(message: string, emotionalContext: string, stage: string): string {
    const contextualResponses = [
      "Entendo o que voc√™ est√° dizendo, e quero que saiba que seus sentimentos s√£o completamente v√°lidos. ü§ó Quer me contar mais sobre isso? Estou aqui para te escutar sem julgamentos e te apoiar no que precisar.",
      "Que perspectiva interessante! üí≠ Como voc√™ se sente em rela√ß√£o a isso? √Äs vezes conversar sobre nossos pensamentos e sentimentos nos ajuda a entend√™-los melhor e encontrar clareza.",
      "Percebo que isso √© importante para voc√™, e admiro sua coragem de compartilhar. üå∏ Que tal explorarmos esse assunto juntos? Estou aqui para te acompanhar nessa reflex√£o com todo carinho.",
      "Obrigada por confiar em mim e compartilhar isso. üíú Sua abertura √© um sinal de for√ßa. Como posso te ajudar a processar esses sentimentos ou pensamentos? Estou aqui para te apoiar sempre."
    ];

    return contextualResponses[Math.floor(Math.random() * contextualResponses.length)];
  }

  async generateResponse(userMessage: string, context?: ChatContext): Promise<AIResponse> {
    this.requestCount++;

    // Add to conversation history
    this.conversationHistory.push({ role: 'user', content: userMessage });

    try {
      // Try external APIs first (in order of preference)
      let aiResponse = await this.tryOllamaWeb(userMessage);
      
      if (!aiResponse) {
        aiResponse = await this.tryPerplexityLabs(userMessage);
      }
      
      if (!aiResponse) {
        aiResponse = await this.tryTogetherAI(userMessage);
      }

      if (!aiResponse) {
        aiResponse = await this.tryReplicate(userMessage);
      }

      // If all external APIs fail, use our VERY intelligent fallback
      if (!aiResponse) {
        aiResponse = this.generateIntelligentResponse(userMessage, context);
      }

      // Clean up the response
      aiResponse = this.cleanResponse(aiResponse);

      // Add AI response to history
      this.conversationHistory.push({ role: 'assistant', content: aiResponse });
      
      // Keep conversation history manageable
      if (this.conversationHistory.length > 20) {
        this.conversationHistory = this.conversationHistory.slice(-20);
      }

      const responseType = this.detectResponseType(aiResponse, userMessage);
      const quickReplies = this.generateQuickReplies(responseType, userMessage);

      return {
        text: aiResponse,
        type: responseType,
        quickReplies,
        timestamp: new Date()
      };

    } catch (error) {
      console.error('Error generating AI response:', error);
      
      // Fallback to intelligent response
      const fallbackResponse = this.generateIntelligentResponse(userMessage, context);
      const responseType = this.detectResponseType(fallbackResponse, userMessage);
      const quickReplies = this.generateQuickReplies(responseType, userMessage);

      return {
        text: fallbackResponse,
        type: responseType,
        quickReplies,
        timestamp: new Date()
      };
    }
  }

  private cleanResponse(response: string): string {
    // Remove any unwanted prefixes or suffixes
    return response
      .replace(/^(Luna:|Assistant:|AI:)/i, '')
      .replace(/\[INST\]|\[\/INST\]/g, '')
      .trim();
  }

  private analyzeMood(text: string): ChatContext['userMood'] {
    const moodKeywords = {
      sad: ['triste', 'deprimido', 'sozinho', 'perdido', 'mal', 'choro', 'dor', 'sofrendo', 'machucado', 'devastado'],
      anxious: ['ansioso', 'nervoso', 'preocupado', 'medo', 'assustado', 'p√¢nico', 'estresse', 'tenso', 'inquieto'],
      angry: ['raiva', 'bravo', 'irritado', '√≥dio', 'furioso', 'revoltado', 'injusto', '√≥dio', 'indignado'],
      hopeful: ['esperan√ßa', 'melhor', 'futuro', 'recome√ßo', 'otimista', 'confiante', 'positivo', 'bem', 'animado'],
      confused: ['confuso', 'n√£o sei', 'd√∫vida', 'perdido', 'como', 'por que', 'entender', 'incerto']
    };
    
    const lowerText = text.toLowerCase();
    
    for (const [mood, keywords] of Object.entries(moodKeywords)) {
      if (keywords.some(keyword => lowerText.includes(keyword))) {
        return mood as ChatContext['userMood'];
      }
    }
    
    return 'neutral';
  }

  private detectResponseType(response: string, userMessage: string): AIResponse['type'] {
    const lowerResponse = response.toLowerCase();
    const lowerMessage = userMessage.toLowerCase();
    
    // Check user message for emotional content
    const emotionalKeywords = ['triste', 'deprimido', 'sozinho', 'perdido', 'mal', 'ansioso', 'nervoso', 'preocupado', 'medo', 'raiva', 'bravo'];
    const technicalKeywords = ['como', 'funciona', 'scanner', 'deletar', 'app', 'configurar', 'usar'];
    const motivationalKeywords = ['progresso', 'conquista', 'dias', 'futuro', 'motiva√ß√£o', 'for√ßa'];
    const greetingKeywords = ['oi', 'ol√°', 'como voc√™ est√°', 'bom dia', 'boa tarde'];
    
    if (greetingKeywords.some(word => lowerMessage.includes(word))) {
      return 'greeting';
    } else if (emotionalKeywords.some(word => lowerMessage.includes(word))) {
      return 'emotional';
    } else if (technicalKeywords.some(word => lowerMessage.includes(word))) {
      return 'technical';
    } else if (motivationalKeywords.some(word => lowerMessage.includes(word))) {
      return 'motivational';
    }
    
    return 'general';
  }

  private generateQuickReplies(responseType: AIResponse['type'], userMessage: string): string[] {
    const quickReplies: Record<AIResponse['type'], string[]> = {
      emotional: [
        'Obrigado(a) pelo apoio üíú',
        'Como posso me sentir melhor?',
        'Conte mais sobre isso',
        'Preciso de mais motiva√ß√£o'
      ],
      technical: [
        'Entendi, obrigado(a)',
        'Explique mais detalhes',
        'Como usar essa fun√ß√£o?',
        'Outras funcionalidades'
      ],
      motivational: [
        'Isso me motiva! ‚ú®',
        'Quero ver meu progresso',
        'Pr√≥ximos passos?',
        'Celebrar conquistas üéâ'
      ],
      greeting: [
        'Estou bem, obrigado(a)',
        'Preciso de ajuda',
        'Vamos conversar',
        'Como voc√™ funciona?'
      ],
      general: [
        'Interessante',
        'Conte mais',
        'Entendi',
        'E depois?'
      ],
      fallback: [
        'Tentar novamente',
        'Estou bem',
        'Vamos conversar',
        'Mudemos de assunto'
      ]
    };

    return quickReplies[responseType] || quickReplies.general;
  }

  // Public methods for status and control
  isServiceAvailable(): boolean {
    return this.isAvailable;
  }

  getStats() {
    return {
      requestCount: this.requestCount,
      conversationLength: this.conversationHistory.length,
      isAvailable: this.isAvailable,
      serviceType: 'Free AI with Super Intelligent Fallback'
    };
  }

  resetConversation() {
    this.conversationHistory = [];
    this.requestCount = 0;
  }

  // Test method
  async testAI(): Promise<{ success: boolean; response?: string; error?: string }> {
    try {
      const testResponse = await this.generateResponse("Ol√°, voc√™ est√° funcionando?");
      return { 
        success: true, 
        response: testResponse.text 
      };
    } catch (error) {
      return { 
        success: false, 
        error: error.message || 'Unknown error' 
      };
    }
  }

  // Stream response simulation
  async generateStreamResponse(
    userMessage: string, 
    context?: ChatContext, 
    onChunk?: (chunk: string) => void
  ): Promise<AIResponse> {
    const response = await this.generateResponse(userMessage, context);
    
    // Simulate streaming by sending chunks
    if (onChunk) {
      const words = response.text.split(' ');
      let currentText = '';
      
      for (let i = 0; i < words.length; i++) {
        currentText += (i > 0 ? ' ' : '') + words[i];
        onChunk(currentText);
        
        // Small delay to simulate typing
        await new Promise(resolve => setTimeout(resolve, 30 + Math.random() * 40));
      }
    }
    
    return response;
  }
}

// Export singleton instance
export const freeAIService = new FreeAIService();
export default FreeAIService;